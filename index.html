<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>InfoTV Slideshow (Optimalizált v4.3 - Animáció nélkül)</title> <style>
    /* CSS módosítva: Átmenet eltávolítva */
    body, html {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
        background: #000;
    }
    .slideshow-container {
        position: relative;
        width: 100%;
        height: 100%;
    }
    .slide {
        display: none; /* Hide by default */
        position: absolute;
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        /* opacity: 0; */ /* Opacity removed */
        /* transition: opacity 0.8s ease-in-out; */ /* Transition removed */
        overflow: hidden;
    }
    .slide.active {
        display: block; /* Show when active */
        /* opacity: 1; */ /* Opacity removed */
        z-index: 1; /* Ensure active slide is on top */
    }
    /* .slide.previous class is no longer needed for simple show/hide */
    /*
    .slide.previous {
        display: block;
        opacity: 0;
        z-index: 0;
    }
    */
    iframe, img {
        width: 100%;
        height: 100%;
        border: none;
        object-fit: contain;
    }
    #emergency-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        z-index: 1000;
        display: none;
        opacity: 0;
        transition: opacity 0.5s ease-in-out; /* Emergency overlay can keep its fade */
    }
    #emergency-overlay.active {
        display: block;
        opacity: 1;
    }
    #emergency-content {
        width: 100%;
        height: 100%;
    }
    .aktualis-slide {
        position: absolute;
        width: 100%;
        height: 100%;
        background-size: cover;
        background-position: center;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        padding: 2rem;
        box-sizing: border-box;
    }
    .aktualis-text-container {
        color: white;
        text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.7);
        font-family: 'Montserrat', sans-serif;
        max-width: 90%;
        width: fit-content;
        background-color: rgba(0, 0, 0, 0.3);
        padding: 2vw 3vw;
        border-radius: 10px;
        text-align: center;
    }
    .aktualis-first-line {
        font-weight: 700;
        font-size: clamp(24px, 5vw, 60px);
        line-height: 1.2;
        margin-bottom: clamp(10px, 1.5vw, 20px);
        display: block;
        color: #ffffff;
    }
    .aktualis-content {
        font-weight: 400;
        font-size: clamp(16px, 3.5vw, 40px);
        line-height: 1.4;
        color: #ffffff;
    }
    .error-message {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: #111;
        color: #ff6b6b; /* Reddish color for errors */
        font-family: sans-serif;
        font-size: 1.5em;
        text-align: center;
        padding: 20px;
        box-sizing: border-box;
        position: absolute; /* Ensure it covers content */
        top: 0;
        left: 0;
        z-index: 2000; /* Above everything else */
    }
    .error-message code {
        color: #feca57; /* Yellowish for details */
        font-size: 0.7em; /* Smaller font for details */
        margin-top: 15px;
        max-width: 80%;
        overflow-wrap: break-word;
    }
    .error-message .reload-notice {
        margin-top: 20px;
        font-size: 0.8em;
        color: #ccc;
    }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div class="slideshow-container" id="slideshow-container">
        </div>
    <div id="emergency-overlay">
        <div id="emergency-content"></div>
    </div>
    <div id="critical-error-container" style="display: none;"></div>

    <script type="module">
        // Import necessary Firebase functions
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-app.js";
        import {
            getFirestore, doc, setDoc, collection, query, where,
            onSnapshot, orderBy, serverTimestamp, updateDoc,
            addDoc, Timestamp
        } from "https://www.gstatic.com/firebasejs/11.4.0/firebase-firestore.js";

        // --- Firebase Configuration ---
        const firebaseConfig = {
            apiKey: "AIzaSyAmlb3HFiXq18IlV--o1GOC5yofXSZjV48",
            authDomain: "infotv-50232.firebaseapp.com",
            projectId: "infotv-50232",
            storageBucket: "infotv-50232.appspot.com",
            messagingSenderId: "890415866941",
            appId: "1:890415866941:web:10606b06957eca86d43654",
            measurementId: "G-2V1HZ0RPJK"
        };

        // --- Global Variables and Constants ---
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const deviceId = new URLSearchParams(window.location.search).get('id') || 'unknown';

        let allSlidesData = [];
        let currentSlideElements = [];
        let emergencySlides = [];
        let currentSlideIndex = 0;
        // previousSlideIndex is no longer needed for CSS without transition
        // let previousSlideIndex = -1;
        let lastStatus = 'online';
        let lastError = null;
        let cachedDeviceData = {};
        let slidesListenerUnsubscribe = null;
        let emergencyListenerUnsubscribe = null;
        let deviceListenerUnsubscribe = null;
        let slideshowIntervalId = null;
        let isHandlingError = false; // Flag to prevent multiple reload triggers
        const SLIDESHOW_INTERVAL = 30000;
        const HEARTBEAT_INTERVAL = 60000;
        const RELOAD_DELAY = 5000; // Delay before reloading on critical error (ms)

        // --- Utility Functions ---
        function formatDateUTC(date) { /* ... unchanged ... */
             const year = date.getUTCFullYear();
            const month = String(date.getUTCMonth() + 1).padStart(2, '0');
            const day = String(date.getUTCDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }
        function escapeHtml(unsafe) { /* ... unchanged ... */
            if (typeof unsafe !== 'string') return '';
            return unsafe
                 .replace(/&/g, "&amp;")
                 .replace(/</g, "&lt;")
                 .replace(/>/g, "&gt;")
                 .replace(/"/g, "&quot;")
                 .replace(/'/g, "&#039;");
        }
        function renderErrorMessage(container, message, details = '') { /* ... unchanged ... */
             container.innerHTML = `
                <div class="error-message">
                    ${escapeHtml(message)}
                    ${details ? `<code>${escapeHtml(details)}</code>` : ''}
                </div>`;
        }

        // --- Logging and Error Handling ---
        async function logErrorToServer(error, context = "Unknown") { /* ... unchanged ... */
             console.error(`Logging error to server (Context: ${context}):`, error);
            try {
                if (isHandlingError && context !== "handleCriticalError") return;
                await addDoc(collection(db, 'logs'), {
                    eventType: "Eszköz hiba",
                    details: `Hiba történt az eszközön (ID: ${deviceId}, Context: ${context})`,
                    additionalInfo: JSON.stringify(error, Object.getOwnPropertyNames(error)),
                    user: "Rendszer",
                    timestamp: serverTimestamp()
                });
            } catch (e) {
                console.error('CRITICAL: Error logging the error to Firestore:', e);
            }
        }
        function handleCriticalError(error, context) { /* ... unchanged ... */
            if (isHandlingError) return;
            isHandlingError = true;

            console.error(`CRITICAL ERROR in ${context}:`, error);
            logErrorToServer(error, `Critical Error in ${context}`);

            stopSlideshowTimer();
            if (slidesListenerUnsubscribe) slidesListenerUnsubscribe();
            if (emergencyListenerUnsubscribe) emergencyListenerUnsubscribe();
            if (deviceListenerUnsubscribe) deviceListenerUnsubscribe();

            const errorContainer = document.getElementById('critical-error-container');
            if (errorContainer) {
                 renderErrorMessage(
                    errorContainer,
                    "Hiba történt, az alkalmazás újraindul.",
                    `Hiba: ${error.message || 'Ismeretlen hiba'}. Kontextus: ${context}`
                 );
                 const reloadNotice = document.createElement('div');
                 reloadNotice.className = 'reload-notice';
                 reloadNotice.textContent = `Újratöltés ${RELOAD_DELAY / 1000} másodperc múlva...`;
                 errorContainer.firstChild.appendChild(reloadNotice);
                 errorContainer.style.display = 'block';
            }

            console.log(`Reloading page in ${RELOAD_DELAY}ms due to critical error.`);
            setTimeout(() => {
                location.reload();
            }, RELOAD_DELAY);
        }
        window.addEventListener('error', function(event) { /* ... unchanged ... */
            console.error('Global error event caught:', event);
            lastError = {
                message: event.message,
                filename: event.filename,
                lineno: event.lineno,
                colno: event.colno,
                error: event.error?.stack
            };
             logErrorToServer(lastError, "Global window.onerror");
        });
        window.addEventListener('unhandledrejection', function(event) { /* ... unchanged ... */
            console.error('Unhandled rejection event caught:', event);
            lastError = {
                message: 'Unhandled Promise Rejection',
                reason: event.reason instanceof Error ? event.reason.stack : String(event.reason)
            };
             logErrorToServer(lastError, "Global unhandledrejection");
        });

        // --- Device Information and Heartbeat ---
        function getDeviceInfo() { /* ... unchanged ... */
             const userAgent = navigator.userAgent || 'N/A';
            const os = userAgent.includes('Windows') ? 'Windows' :
                       userAgent.includes('Mac') ? 'Mac OS' :
                       userAgent.includes('Linux') ? 'Linux' :
                       userAgent.includes('Android') ? 'Android' :
                       userAgent.includes('like Mac OS X') ? 'iOS' : 'Unknown OS';
            const browser = userAgent.includes('FullyKiosk') ? 'Fully Kiosk' :
                            userAgent.includes('Edg/') ? 'Edge' :
                            userAgent.includes('Chrome') ? 'Chrome' :
                            userAgent.includes('Firefox') ? 'Firefox' :
                            userAgent.includes('Safari') ? 'Safari' : 'Unknown Browser';
            return {
                os,
                browser,
                resolution: `${window.screen.width}x${window.screen.height}`,
                lastError: lastError ? JSON.stringify(lastError, Object.getOwnPropertyNames(lastError), 2) : null
            };
        }
        async function sendDeviceInfo() { /* ... unchanged ... */
             const currentStatus = navigator.onLine ? 'online' : 'offline';
            const statusChanged = currentStatus !== lastStatus;

            if (currentStatus === 'offline') {
                if (statusChanged) {
                    console.warn("Device offline.");
                    lastStatus = 'offline';
                    lastError = { message: 'Network connection lost' };
                }
                return;
            }

            if (isHandlingError) return;

            try {
                const deviceInfoToSend = {
                    ...getDeviceInfo(),
                    lastHeartbeat: serverTimestamp(),
                    status: 'online',
                    ...(statusChanged && lastStatus === 'offline' && { previousStatus: 'offline' }),
                    refresh: cachedDeviceData.refresh ?? false,
                    restart: cachedDeviceData.restart ?? false,
                };

                await setDoc(doc(db, 'devices', deviceId), deviceInfoToSend, { merge: true });

                if (statusChanged && lastStatus === 'offline') {
                    console.log("Device back online.");
                    await addDoc(collection(db, 'logs'), {
                        eventType: "Eszköz állapot változás",
                        details: `Eszköz online állapotba került (ID: ${deviceId})`,
                        user: "Rendszer",
                        timestamp: serverTimestamp()
                    });
                    lastError = null;
                }
                lastStatus = 'online';

            } catch (error) {
                console.error('Failed to send device info:', error);
                lastError = {
                    message: 'Failed to update device info to Firestore',
                    error: error?.message,
                    stack: error?.stack
                };
                if (!error.message.includes('permission')) {
                    logErrorToServer(lastError, "sendDeviceInfo");
                }
            }
        }
        function startDeviceMonitoring() { /* ... unchanged ... */
             sendDeviceInfo();
            setInterval(sendDeviceInfo, HEARTBEAT_INTERVAL);
            window.addEventListener('online', () => {
                console.log("Browser detected online event.");
                sendDeviceInfo();
            });
            window.addEventListener('offline', () => {
                console.warn("Browser detected offline event.");
                lastStatus = 'offline';
                lastError = { message: 'Network connection lost (event listener)' };
            });
        }

        // --- Firestore Listeners Setup ---
        function setupDeviceCommandsListener() { /* ... unchanged ... */
            if (deviceListenerUnsubscribe) {
                deviceListenerUnsubscribe();
            }
            const deviceRef = doc(db, 'devices', deviceId);
            console.log(`Setting up listener for device: ${deviceId}`);

            deviceListenerUnsubscribe = onSnapshot(deviceRef, async (docSnapshot) => {
                try {
                    if (!docSnapshot.exists()) {
                        console.warn("Device document does not exist:", deviceId);
                        cachedDeviceData = {};
                        return;
                    }

                    const data = docSnapshot.data();
                    cachedDeviceData = data;
                    console.log("Received device data update:", cachedDeviceData);

                    // Handle refresh/restart commands
                    if (data?.refresh === true) {
                        console.log("Refresh command received.");
                        await updateDoc(deviceRef, { refresh: false });
                        await addDoc(collection(db, 'logs'), { eventType: "Eszköz parancs", details: `Eszköz frissítés parancs végrehajtva (ID: ${deviceId})`, user: "Rendszer", timestamp: serverTimestamp() });
                        location.reload();
                    }
                    if (data?.restart === true) {
                        console.log("Restart command received.");
                        await updateDoc(deviceRef, { restart: false });
                        await addDoc(collection(db, 'logs'), { eventType: "Eszköz parancs", details: `Eszköz újraindítás parancs végrehajtva (ID: ${deviceId})`, user: "Rendszer", timestamp: serverTimestamp() });
                        setTimeout(() => location.reload(), 500);
                    }
                } catch (error) {
                     handleCriticalError(error, "setupDeviceCommandsListener callback");
                }

            }, (error) => {
                console.error("Error listening to device document:", error);
                lastError = { message: "Firestore listener error (device doc)", error: error?.message, stack: error?.stack };
                logErrorToServer(lastError, "setupDeviceCommandsListener listener error");
                cachedDeviceData = {};
            });
        }
        function setupSlidesListener() { /* ... unchanged ... */
            if (slidesListenerUnsubscribe) {
                slidesListenerUnsubscribe();
            }
            const todayStr = formatDateUTC(new Date());
            console.log(`Setting up slides listener for date >= ${todayStr}`);
            const slidesQuery = query(
                 collection(db, 'slides'),
                where('active', '==', true),
                where('startDate', '<=', todayStr),
                orderBy('startDate', 'desc'),
                orderBy("order", "asc")
            );

            slidesListenerUnsubscribe = onSnapshot(slidesQuery, (snapshot) => {
                try {
                    const now = new Date();
                    console.log(`Received ${snapshot.docs.length} potential slides from listener.`);

                    const newSlidesData = snapshot.docs
                        .map(doc => ({ id: doc.id, ...doc.data() }))
                        .filter(slide => {
                            if (slide.active !== true) return false;
                            try {
                                const startDate = new Date(Date.UTC(parseInt(slide.startDate.substring(0, 4)), parseInt(slide.startDate.substring(5, 7)) - 1, parseInt(slide.startDate.substring(8, 10)), 0, 0, 0, 0));
                                if (startDate > now) return false;
                            } catch(e) { console.error("Invalid startDate:", slide.id, slide.startDate, e); return false; }
                            if (slide.endDate) {
                                try {
                                    const endOfDay = new Date(Date.UTC(parseInt(slide.endDate.substring(0, 4)), parseInt(slide.endDate.substring(5, 7)) - 1, parseInt(slide.endDate.substring(8, 10)), 23, 59, 59, 999));
                                    if (endOfDay < now) return false;
                                } catch (e) { console.error("Invalid endDate:", slide.id, slide.endDate, e); return false; }
                            }
                            return true;
                        });

                    console.log(`Filtered down to ${newSlidesData.length} valid slides.`);
                    const dataChanged = JSON.stringify(allSlidesData) !== JSON.stringify(newSlidesData);

                    if (dataChanged) {
                        console.log(`Slide data updated. New count: ${newSlidesData.length}. Rebuilding DOM.`);
                        allSlidesData = newSlidesData;
                        addDoc(collection(db, 'logs'), { eventType: "Dia lista frissítés (real-time)", details: `Dia lista frissült (${allSlidesData.length} aktív dia), DOM újraépítés. Eszköz: ${deviceId}`, user: "Rendszer", timestamp: serverTimestamp() }).catch(e => console.error("Failed to log slide update:", e));
                        rebuildSlidesDOM();
                    } else {
                        console.log("Slide data received, but no effective changes detected after filtering.");
                    }
                } catch (error) {
                    handleCriticalError(error, "setupSlidesListener callback");
                }

            }, (error) => {
                console.error("Error listening to slides collection:", error);
                lastError = { message: "Firestore listener error (slides)", error: error?.message, stack: error?.stack };
                logErrorToServer(lastError, "setupSlidesListener listener error");
                allSlidesData = [];
                rebuildSlidesDOM();
            });
        }
        function setupEmergencySlidesListener() { /* ... unchanged ... */
             if (emergencyListenerUnsubscribe) {
                emergencyListenerUnsubscribe();
            }
            console.log("Setting up emergency slides listener.");
            const emergencyQuery = query(
                 collection(db, 'emergency_slides'),
                where('active', '==', true)
            );

            emergencyListenerUnsubscribe = onSnapshot(emergencyQuery, (snapshot) => {
                try {
                    const previousLength = emergencySlides.length;
                    emergencySlides = snapshot.docs
                                        .map(doc => ({ id: doc.id, ...doc.data() }))
                                        .filter(slide => slide.active === true);

                    console.log(`Received ${emergencySlides.length} active emergency slides.`);

                    if (previousLength !== emergencySlides.length) {
                        console.log(`Emergency state changed: ${emergencySlides.length > 0 ? 'ACTIVE' : 'INACTIVE'}`);
                        addDoc(collection(db, 'logs'), { eventType: "Havária állapot változás", details: `Havária ${emergencySlides.length > 0 ? 'aktiválva' : 'deaktiválva'} (${emergencySlides.length} dia). Eszköz: ${deviceId}`, user: "Rendszer", timestamp: serverTimestamp() }).catch(e => console.error("Failed to log emergency state change:", e));
                    }
                    renderEmergencyOverlay();
                } catch (error) {
                    handleCriticalError(error, "setupEmergencySlidesListener callback");
                }
            }, (error) => {
                console.error("Error listening to emergency slides:", error);
                lastError = { message: "Firestore listener error (emergency slides)", error: error?.message, stack: error?.stack };
                logErrorToServer(lastError, "setupEmergencySlidesListener listener error");
                emergencySlides = [];
                renderEmergencyOverlay();
            });
        }

        // --- Slide Rendering and Logic ---

        function createSlideElement(slideData) { /* ... unchanged ... */
            const slideElement = document.createElement('div');
            slideElement.className = 'slide';
            slideElement.dataset.slideId = slideData.id;

            try {
                switch (slideData.type) {
                    case 'image':
                        slideElement.innerHTML = `<img src="${slideData.content || ''}" alt="Slide ${escapeHtml(slideData.id)}" loading="lazy" onerror="this.parentElement.innerHTML = '<div class=\\'error-message\\'>Kép betöltési hiba<br><code>ID: ${escapeHtml(slideData.id)}</code></div>';">`;
                        break;
                    case 'embed':
                        slideElement.innerHTML = `<iframe src="${slideData.content || ''}" title="Slide ${escapeHtml(slideData.id)}" loading="lazy" sandbox="allow-scripts allow-same-origin allow-popups allow-forms"></iframe>`;
                        break;
                    case 'aktuális':
                        const contentData = typeof slideData.content === 'string' ? JSON.parse(slideData.content) : slideData.content;
                        const presetLink = contentData?.presetLink || '';
                        const firstLine = contentData?.firstLine || '';
                        const text = contentData?.text || '';
                        slideElement.innerHTML = `
                            <div class="aktualis-slide" style="background-image: url('${presetLink}');">
                                <div class="aktualis-text-container">
                                    ${firstLine ? `<div class="aktualis-first-line">${escapeHtml(firstLine)}</div>` : ''}
                                    ${text ? `<div class="aktualis-content">${escapeHtml(text)}</div>` : ''}
                                </div>
                            </div>`;
                        break;
                    default:
                         console.warn("Unknown slide type:", slideData.type, slideData.id);
                         renderErrorMessage(slideElement, `Ismeretlen diatípus: ${escapeHtml(slideData.type)}`, `ID: ${escapeHtml(slideData.id)}`);
                }
            } catch (e) {
                console.error(`Error creating slide element ID ${slideData.id}, type ${slideData.type}:`, e, slideData.content);
                renderErrorMessage(slideElement, `Hiba a dia létrehozásakor`, `ID: ${escapeHtml(slideData.id)}`);
                logErrorToServer(e, `createSlideElement ${slideData.type}`);
            }
            return slideElement;
        }


        function rebuildSlidesDOM() { /* ... unchanged ... */
            try {
                const container = document.getElementById('slideshow-container');
                if (!container) {
                    throw new Error("Slideshow container element not found in DOM.");
                }

                console.log("Rebuilding slides DOM...");
                const slidesToDisplayData = [...allSlidesData];

                container.innerHTML = '';
                currentSlideElements = [];

                console.log(`Attempting to render ${slidesToDisplayData.length} valid slides.`);

                if (slidesToDisplayData.length === 0) {
                    console.warn("No slides to display after filtering.");
                    renderErrorMessage(container, "Nincsenek megjeleníthető diák.", `(ID: ${deviceId})`);
                    stopSlideshowTimer();
                    currentSlideIndex = 0;
                    // previousSlideIndex = -1; // Not needed anymore
                    return;
                }

                slidesToDisplayData.forEach((slideData) => {
                    const slideElement = createSlideElement(slideData);
                    container.appendChild(slideElement);
                    currentSlideElements.push(slideElement);
                });

                if (currentSlideIndex >= currentSlideElements.length) {
                    console.warn(`Resetting slide index from ${currentSlideIndex} to 0 because it's out of bounds (${currentSlideElements.length} slides).`);
                    currentSlideIndex = 0;
                    // previousSlideIndex = -1; // Not needed anymore
                } else {
                     console.log(`Current index ${currentSlideIndex} is valid for ${currentSlideElements.length} slides.`);
                }


                console.log(`DOM rebuilt with ${currentSlideElements.length} elements. Setting slide ${currentSlideIndex} as active.`);

                currentSlideElements.forEach((el, index) => {
                    if (el) {
                        el.classList.remove('active', 'previous'); // Remove previous class too
                        if (index === currentSlideIndex) {
                            el.classList.add('active');
                        }
                    } else {
                        console.error(`Slide element at index ${index} is unexpectedly null during activation.`);
                    }
                });

                if (currentSlideElements.length > 1) {
                    startSlideshowTimer();
                } else {
                    stopSlideshowTimer();
                }
            } catch (error) {
                 handleCriticalError(error, "rebuildSlidesDOM");
            }
        }


        function renderEmergencyOverlay() { /* ... unchanged ... */
            try {
                const overlay = document.getElementById('emergency-overlay');
                const content = document.getElementById('emergency-content');
                if (!overlay || !content) {
                     console.error("Emergency overlay elements not found!");
                     return;
                }

                if (emergencySlides.length > 0) {
                    const slide = emergencySlides[0];
                    console.log(`Activating emergency overlay with slide: ${slide.id}`);
                    content.innerHTML = '';

                    try {
                        if (slide.type === 'image') {
                            content.innerHTML = `<img src="${slide.content || ''}" alt="Emergency Slide ${escapeHtml(slide.id)}" onerror="this.parentElement.innerHTML = '<div class=\\'error-message\\'>Havária kép hiba<br><code>ID: ${escapeHtml(slide.id)}</code></div>';">`;
                        } else if (slide.type === 'embed') {
                            content.innerHTML = `<iframe src="${slide.content || ''}" title="Emergency Slide ${escapeHtml(slide.id)}" loading="lazy" sandbox="allow-scripts allow-same-origin allow-popups allow-forms"></iframe>`;
                        } else {
                            console.warn("Unsupported emergency slide type:", slide.type, slide.id);
                            renderErrorMessage(content, `Ismeretlen havária diatípus: ${escapeHtml(slide.type)}`, `ID: ${escapeHtml(slide.id)}`);
                        }
                    } catch (renderError) {
                        console.error(`Error rendering emergency slide ID ${slide.id}:`, renderError);
                        logErrorToServer(renderError, `renderEmergencyOverlay slide ${slide.id}`);
                        renderErrorMessage(content, `Hiba a havária dia megjelenítésekor`, `ID: ${escapeHtml(slide.id)}`);
                    }

                    overlay.classList.add('active');
                    stopSlideshowTimer();

                } else {
                    if (overlay.classList.contains('active')) {
                        console.log("Deactivating emergency overlay.");
                        overlay.classList.remove('active');
                        content.innerHTML = '';
                        rebuildSlidesDOM();
                    }
                }
            } catch (error) {
                 handleCriticalError(error, "renderEmergencyOverlay");
            }
        }

        /**
         * Advances to the next slide by manipulating CSS classes. No transition.
         */
        function nextSlide() {
            try {
                 const overlay = document.getElementById('emergency-overlay');
                 if (overlay && overlay.classList.contains('active')) {
                    return;
                 }

                if (currentSlideElements.length <= 1) {
                    return;
                }

                // Get the currently active element BEFORE calculating the next index
                const previousElement = currentSlideElements[currentSlideIndex];

                // Calculate next index
                currentSlideIndex = (currentSlideIndex + 1) % currentSlideElements.length;

                // Get the new active element
                const nextElement = currentSlideElements[currentSlideIndex];

                // Hide the previous slide (if it exists)
                if (previousElement) {
                     previousElement.classList.remove('active');
                     // No need for 'previous' class anymore
                } else if (currentSlideElements.length > 0) {
                     // This case should ideally not happen if index management is correct
                     console.warn(`nextSlide: Previous element at index ${ (currentSlideIndex - 1 + currentSlideElements.length) % currentSlideElements.length } was null.`);
                }


                // Show the new active slide (if it exists)
                if (nextElement) {
                     nextElement.classList.add('active');
                } else {
                     // This indicates a serious problem with the element list or index
                     console.error(`nextSlide: Next element at index ${currentSlideIndex} is null.`);
                     throw new Error(`Slide element at index ${currentSlideIndex} not found during nextSlide.`);
                }

            } catch (error) {
                 handleCriticalError(error, "nextSlide");
            }
        }


        function startSlideshowTimer() { /* ... unchanged ... */
             stopSlideshowTimer();
            console.log(`Starting slideshow timer (${SLIDESHOW_INTERVAL}ms)`);
            slideshowIntervalId = setInterval(nextSlide, SLIDESHOW_INTERVAL);
        }
        function stopSlideshowTimer() { /* ... unchanged ... */
             if (slideshowIntervalId) {
                clearInterval(slideshowIntervalId);
                slideshowIntervalId = null;
                console.log("Stopped slideshow timer.");
            }
        }

        // --- Initialization ---
        function initializeAppLogic() { /* ... unchanged ... */
             try {
                console.log("Initializing InfoTV Slideshow App (v4.3 - No Animation)..."); // Version bump
                console.log("Device ID:", deviceId);

                startDeviceMonitoring();
                setupDeviceCommandsListener();
                setupEmergencySlidesListener();
                setupSlidesListener();

                console.log("Initialization complete. Waiting for data from Firestore...");
             } catch(error) {
                 handleCriticalError(error, "initializeAppLogic");
             }
        }

        // Run initialization logic
        if (document.readyState === 'loading') { /* ... unchanged ... */
             document.addEventListener('DOMContentLoaded', initializeAppLogic);
        } else {
            initializeAppLogic();
        }

        // Cleanup listeners on page unload
        window.addEventListener('beforeunload', () => { /* ... unchanged ... */
            console.log("Unsubscribing Firestore listeners before unload.");
            if (slidesListenerUnsubscribe) slidesListenerUnsubscribe();
            if (emergencyListenerUnsubscribe) emergencyListenerUnsubscribe();
            if (deviceListenerUnsubscribe) deviceListenerUnsubscribe();
            stopSlideshowTimer();
        });

    </script>
</body>
</html>
